<!doctype html>
<html lang="fr-fr">
  <head>
    <title>Application pratique du paradoxe des anniversaires // Phidra&#39;s blog</title>
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.81.0-DEV" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    
    <meta name="author" content="phidra" />
    

    
    <meta name="description" content="blog tech C&#43;&#43; python dev" />
    

    <link rel="stylesheet" href="https://phidra.github.io/blog/css/main.min.7a031c63f91e76e2f20780fa544c7984e864efc78057fa7ad2792849259c0d15.css" />

    

    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  </head>
  <body>
    <header class="app-header">

      
      
      <a href="https://phidra.github.io/blog/" id="avatar">
          <img src="/blog/img/general/phi_medium_fond_blanc.png" alt="phidra" />
      </a>
      

      <a href="https://phidra.github.io/blog/">
        <h1 class="title">Phidra&#39;s blog</h1>
      </a>

      
      <input class="burger" type="checkbox">
      <nav>
        <a href="https://phidra.github.io/blog/">                <i class="material-icons"> home </i>Posts       </a>
        <a href="https://phidra.github.io/blog/menu/notes/">      <i class="material-icons"> event_note </i>Notes       </a>
        <a href="https://phidra.github.io/blog/menu/references/"> <i class="material-icons"> menu_book </i>Références  </a>
        <a href="https://phidra.github.io/blog/menu/in2words/"> <i class="material-icons"> school </i>En 2 mots  </a>
        <a href="https://phidra.github.io/blog/menu/about/">      <i class="material-icons"> info </i>À propos    </a>
      </nav>

    </header>

    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">Application pratique du paradoxe des anniversaires</h1>
      <div class="post-meta">
        <div>
          Aug 8, 2020
          —
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          11 min read
        </div></div>
    <div>
        <nav id="TableOfContents">
  <ul>
    <li><a href="#_création_dune_base_temporaire">Création d’une base temporaire</a></li>
    <li><a href="#_paradoxe_des_anniversaires">Paradoxe des anniversaires</a></li>
    <li><a href="#_implémentations_alternatives">Implémentations alternatives</a></li>
    <li><a href="#_le_meilleur_code_est_celui_quon_nécrit_pas">Le meilleur code est celui qu’on n’écrit pas</a></li>
    <li><a href="#_pour_conclure">Pour conclure</a></li>
  </ul>
</nav>
    </div>
    </header>
    <div class="post-content">
      <div id="preamble">
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_création_dune_base_temporaire">Création d’une base temporaire</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Lors d’une revue de code, je suis tombé récemment sur la création d’une base de données temporaire :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight" style="background: #272822; color: #f8f8f2"><code data-lang="python"><span></span><span style="color: #f8f8f2">db_name</span> <span style="color: #f92672">=</span> <span style="color: #e6db74">&#34;test_{}&#34;</span><span style="color: #f92672">.</span><span style="color: #f8f8f2">format(randrange(</span><span style="color: #ae81ff">1000</span><span style="color: #f8f8f2">))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Le contexte : un test a besoin d’une base de données vierge, il créée donc une base temporaire dont le nom est celui de la ligne ci-dessus, puis la supprime après utilisation. Le sujet qui nous intéresse aujourd’hui : pour s’assurer sans trop d’effort que des exécutions concurrentes du test ne se marcheront pas dessus, le nom de la base temporaire comporte un suffixe aléatoire : <code>randrange(1000)</code>.</p>
</div>
<div class="paragraph">
<p>Est-ce suffisant ? Stricto sensu, non : si un premier test créée la base <code>test_42</code>, un deuxième test a une petite chance de tomber sur le même suffixe <code>42</code>. La <em>petite chance</em> en question est faible : une chance sur mille, si le générateur de nombres aléatoires est parfait.</p>
</div>
<div class="paragraph">
<p>On peut ainsi choisir un seuil à partir duquel on considèrera que les collisions sont tellement peu probables qu’elles peuvent être ignorées. Par exemple, on peut considérer que tant qu’on a moins de <code>5%</code> de chances de tomber sur un suffixe déjà pris, ça nous conviendra. Avec <code>randrange(1000)</code>, un deuxième test concurrent a une probabilité de collision de <code>0.1%</code> ce qui est bien inférieur à notre seuil de <code>5%</code>, on confirme donc qu’utiliser <code>randrange(1000)</code> est suffisant.</p>
</div>
<div class="paragraph">
<p> </p><details><summary> 
FACULTATIF : sur ce seuil de <code>5%</code>
 </summary><div> <p></p>
</div>
<div class="paragraph">
<p>Ce seuil de <code>5%</code> peut paraître élevé, surtout si une collision a des conséquences gênantes : le test échoue de façon non-reproductible, et peut-être d’une façon obscure. Considérer comme acceptable d’avoir une chance sur vingt que ça arrive semble douteux, et en pratique, on utiliserait sans doute un seuil plus restrictif. La suite de l’article proposera de meilleures approches, mais pour le moment, ce seuil de <code>5%</code> m’arrange bien pour illustrer mon exemple. À titre anecdotique, le contexte est différent, mais ce seuil de 5% est souvent <a href="https://fr.wikipedia.org/wiki/Valeur_p#Approche_classique">retenu en statistique</a>, notamment en médecine (même si ça <a href="https://www.tandfonline.com/doi/full/10.1080/00031305.2016.1154108">suscite des discussions</a>). Par exemple, voici un extrait d’un des premiers résultats obtenus en recherchant <code>médecine p-value</code> sur Google :</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>La valeur «p» est la probabilité de commettre une erreur en affirmant l’existence d’une différence quand en réalité aucune différence n’est présente. Plus elle est petite, moins le hasard est responsable du résultat observé, mais elle n’est jamais nulle car elle correspond à une surface sous une courbe asymptotique. Un résultat est usuellement considéré comme statistiquement significatif si la valeur «p» est strictement inférieure à 5% (p &lt; 0,05).</p>
</div>
</blockquote>
<div class="attribution">
— <a href="https://www.revmed.ch/RMS/2015/RMS-N-459/Statistiquement-significatif-benefique-pour-le-patient">Statistiquement significatif : bénéfique pour le patient ?</a>
</div>
</div>
<div class="paragraph">
<p> </p></div></details> <p></p>
</div>
<div class="paragraph">
<p>Si on n’y prend pas garde, on pourrait se dire qu’avec notre seuil de <code>5%</code>, avec un suffixe aléatoire choisi entre <code>0</code> et <code>999</code>, on &#34;s’autorise&#34; une cinquantaine d’exécutions concurrentes du test. Et on aurait tout faux : avec cinquante exécutions concurrentes, la probabilité d’une collision n’est pas de <code>5%</code> mais de …​ <code>71%</code> !</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_paradoxe_des_anniversaires">Paradoxe des anniversaires</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Cette situation est une application du <a href="https://fr.wikipedia.org/wiki/Paradoxe_des_anniversaires">paradoxe des anniversaires</a>, qui n’est pas vraiment un paradoxe, mais plutôt un résultat contre-intuitif. Il tire son nom du problème suivant, formellement identique au nôtre : si on a un groupe de <code>N</code> personnes, à partir de quelle valeur de <code>N</code> a-t-on une majorité de chances qu’au moins deux personnes partagent le même anniversaire ?</p>
</div>
<div class="paragraph">
<p>Plutôt que d’estimer la probabilité que deux personnes partagent le même anniversaire (probabilité d’une collision), il est plus facile de commencer par estimer la probabilité que <strong>toutes les personnes</strong> aient des anniversaires <strong>différents</strong>, c’est à dire la probabilité de NE PAS avoir de collision. Pour cela, on va compter pour chacune des <code>N</code> personnes du groupe les jours &#34;libres&#34; :</p>
</div>
<div class="ulist">
<ul>
<li>
<p>pour la <strong>première</strong> personne du groupe, il y a <code>365</code> jours libres sur les <code>365</code> que comptent le calendrier (on pourrait ignorer cette première personne car elle ne modifie pas la probabilité, mais la formule est plus jolie si on la prend en compte)</p>
</li>
<li>
<p>pour la <strong>deuxième</strong> personne du groupe, comme l’un des 365 jours a été &#34;consommé&#34; par la première personne, il ne reste plus que <code>364</code> jours libres sur les <code>365</code> du calendrier</p>
</li>
<li>
<p>pour la <strong>troisième</strong> personne du groupe, même principe : il ne reste plus que <code>363</code> jours libres sur <code>365</code></p>
</li>
<li>
<p>etc.</p>
</li>
<li>
<p>pour la <strong><code>N</code>-ième et dernière</strong> personne du groupe, il ne reste plus que <code>366-N</code> jours libres sur <code>365</code></p>
</li>
<li>
<p>(et si <code>N</code> est supérieur à <code>365</code>, on n’a plus aucune chance d’éviter une collision)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>La probabilité que les <code>N</code> personnes du groupe aient toutes des anniversaires différents est donc de :</p>
</div>
<div class="paragraph">
<p><code>365/365 * 364/365 * …​ * (366-N)/365</code></p>
</div>
<div class="paragraph">
<p>Soit :</p>
</div>
<div class="paragraph">
<p><code>365*364*…​*(366-N) / 365^N</code></p>
</div>
<div class="paragraph">
<p>La probabilité d’avoir au moins une collision étant complémentaire de la probabilité de ne pas en avoir, on en déduit que la probabilité qu’au moins deux personnes aient leur anniversaire le même jour dans un groupe de <code>N</code> personnes est de :</p>
</div>
<div class="paragraph">
<p><code>1  -  365*364*…​*(366-N) / 365^N</code></p>
</div>
<div class="paragraph">
<p>On peut alors calculer la réponse recherchée : on aura une majorité de chances que deux personnes aient le même anniversaire à partir de <code>23</code> personnes dans le groupe :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight" style="background: #272822; color: #f8f8f2"><code data-lang="python"><span></span><span style="color: #f92672">from</span> <span style="color: #f8f8f2">functools</span> <span style="color: #f92672">import</span> <span style="color: #f8f8f2">reduce</span>
<span style="color: #ae81ff">1</span> <span style="color: #f92672">-</span> <span style="color: #f8f8f2">(reduce(</span><span style="color: #66d9ef">lambda</span> <span style="color: #f8f8f2">x,</span> <span style="color: #f8f8f2">y:</span> <span style="color: #f8f8f2">x</span><span style="color: #f92672">*</span><span style="color: #f8f8f2">y,</span> <span style="color: #f8f8f2">range(</span><span style="color: #ae81ff">366</span><span style="color: #f92672">-</span><span style="color: #ae81ff">23</span><span style="color: #f8f8f2">,</span> <span style="color: #ae81ff">366</span><span style="color: #f8f8f2">))</span> <span style="color: #f92672">/</span> <span style="color: #ae81ff">365</span><span style="color: #f92672">**</span><span style="color: #ae81ff">23</span><span style="color: #f8f8f2">)</span>
<span style="color: #75715e"># 0.5072972343239854</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Ce résultat se généralise : lorsqu’on peut tirer aléatoirement parmi <code>RANGE</code> valeurs, si on fait <code>N</code> tirages, la probabilité d’avoir au moins une collision est :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight" style="background: #272822; color: #f8f8f2"><code data-lang="python"><span></span><span style="color: #f8f8f2">RANGE</span><span style="color: #f92672">=</span><span style="color: #ae81ff">365</span>
<span style="color: #f8f8f2">N</span> <span style="color: #f92672">=</span> <span style="color: #ae81ff">23</span>
<span style="color: #ae81ff">1</span> <span style="color: #f92672">-</span> <span style="color: #f8f8f2">(reduce(</span><span style="color: #66d9ef">lambda</span> <span style="color: #f8f8f2">x,</span> <span style="color: #f8f8f2">y:</span> <span style="color: #f8f8f2">x</span><span style="color: #f92672">*</span><span style="color: #f8f8f2">y,</span> <span style="color: #f8f8f2">range(RANGE</span><span style="color: #f92672">+</span><span style="color: #ae81ff">1</span><span style="color: #f92672">-</span><span style="color: #f8f8f2">N,</span> <span style="color: #f8f8f2">RANGE</span><span style="color: #f92672">+</span><span style="color: #ae81ff">1</span><span style="color: #f8f8f2">))</span> <span style="color: #f92672">/</span> <span style="color: #f8f8f2">RANGE</span><span style="color: #f92672">**</span><span style="color: #f8f8f2">N)</span>
<span style="color: #75715e"># 0.5072972343239854</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Appliquée à notre création d’une base de données temporaire suffixée par <code>randrange(1000)</code>, avec 50 exécutions temporaires, on trouve une probabilité de collision de <code>71%</code> :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight" style="background: #272822; color: #f8f8f2"><code data-lang="python"><span></span><span style="color: #f8f8f2">RANGE</span><span style="color: #f92672">=</span><span style="color: #ae81ff">1000</span>
<span style="color: #f8f8f2">N</span> <span style="color: #f92672">=</span> <span style="color: #ae81ff">50</span>
<span style="color: #ae81ff">1</span> <span style="color: #f92672">-</span> <span style="color: #f8f8f2">(reduce(</span><span style="color: #66d9ef">lambda</span> <span style="color: #f8f8f2">x,</span> <span style="color: #f8f8f2">y:</span> <span style="color: #f8f8f2">x</span><span style="color: #f92672">*</span><span style="color: #f8f8f2">y,</span> <span style="color: #f8f8f2">range(RANGE</span><span style="color: #f92672">+</span><span style="color: #ae81ff">1</span><span style="color: #f92672">-</span><span style="color: #f8f8f2">N,</span> <span style="color: #f8f8f2">RANGE</span><span style="color: #f92672">+</span><span style="color: #ae81ff">1</span><span style="color: #f8f8f2">))</span> <span style="color: #f92672">/</span> <span style="color: #f8f8f2">RANGE</span><span style="color: #f92672">**</span><span style="color: #f8f8f2">N)</span>
<span style="color: #75715e"># 0.712268656879987</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Et le nombre maximal d’exécutions concurrentes autorisées pour rester en dessous de notre seuil de <code>5%</code> est tout pile <code>10</code> : au delà, on dépasse le seuil.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_implémentations_alternatives">Implémentations alternatives</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Fort de tous ces beaux calculs, on fait quoi ? Voici quelques implémentations alternatives à ce <code>randrange(1000)</code> :</p>
</div>
<div class="sect2">
<h3 id="_garder_le_même_principe">Garder le même principe</h3>
<div class="paragraph">
<p>Si on veut conserver une probabilité de collisions inférieure à <code>5%</code> tout en autorisant <code>50</code> exécutions concurrentes, on a vu que <code>randrange(1000)</code> était trop petit. Mais en augmentant le nombre de suffixes possibles, on va finir par faire baisser suffisamment la probabilité de collisions pour descendre sous notre seuil. En l’occurence, tirer un suffixe au hasard parmi environ <code>24000</code> est suffisant.</p>
</div>
<div class="paragraph">
<p>L’inconvénient de cette approche est que le seuil dépend du contexte : si demain on a besoin de <code>100</code> exécutions concurrentes, il ne faudra pas oublier d’adapter cette valeur de <code>24000</code>. De plus, la raison pour laquelle on choisit cette constante plutôt qu’une autre peut ne pas apparaître clairement à la lecture du code, ou être lourde à documenter.</p>
</div>
</div>
<div class="sect2">
<h3 id="_utiliser_la_date">Utiliser la date</h3>
<div class="paragraph">
<p>Une possibilité est d’utiliser la date du lancement du test pour nommer la base, par exemple <code>test_2020-08-08T10:24:31</code>.</p>
</div>
<div class="paragraph">
<p>L’inconvénient de cette approche est qu’il est facile de se tirer une balle dans le pied : on entre dans le royaume des problèmes-qui-viennent-avec-la-gestion-du-temps.</p>
</div>
<div class="paragraph">
<p>Par exemple, la précision du datetime utilisé doit être suffisante pour éviter les collisions. Avec l’exemple deux lignes plus haut, si deux tests s’exécutent dans la même seconde, ils partageront la même base de données. De plus, si la base est créée sur un serveur centralisé, et si les horloges de deux clients ne sont pas synchronisées, ils pourraient créer la même base même si les deux exécutions ne sont pas simultanées. Ou encore si le datetime utilisé est exprimé dans une timezone locale plutôt qu’UTC, deux devs dans des fuseaux horaires différents pourront créer la même base à plusieurs heures d’intervalle.</p>
</div>
<div class="paragraph">
<p>Évidemment, on peut coupler cette approche avec une composante random, mais ça complexifie l’implémentation, ça fait un peu doublon, et on en revient alors de toutes façons aux soucis liés à la randomisation.</p>
</div>
<div class="paragraph">
<p>Mais il faut reconnaître que dans des situations simples, où les problèmes mentionnés ci-dessus ne se produiront pas, cette approche présente l’avantage de la simplicité et de la fiabilité (pas d’aléatoire). En outre, elle facilite l’identification d’une base : <code>test_2020-08-08T10:24:31</code> véhicule plus d’information que <code>test_4552</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_utiliser_un_uuid">Utiliser un uuid</h3>
<div class="paragraph">
<p>Les <a href="https://en.wikipedia.org/wiki/Universally_unique_identifier">UUID</a>, ou plutôt les <a href="https://tools.ietf.org/html/rfc4122.html#section-4.4">UUID version 4</a>, répondent exactement à notre besoin. Ils permettent d’attribuer un identifiant unique à un objet. Le principe est le même que notre <code>randrange(24000)</code>, mais avec une constante très importante. C’est standardisé, et (correctement) implémenté à peu près partout :</p>
</div>
<div class="listingblock">
<div class="content">
<pre># bash :
uuid -v 4

# python :
import uuid ; uuid.uuid4()

# cpp :
#include &lt;boost/uuid/uuid_generators.hpp&gt;
boost::uuids::uuid u = boost::uuids::random_generator()();

# js :
npm install uuid4
const uuid4 = require(&#34;uuid4&#34;);
uuid4();</pre>
</div>
</div>
<div class="paragraph">
<p>Même si dire qualifier d’unique l’identifiant est un abus de langage (car il n’est unique qu&#39;<em>avec une forte probabilité</em>), en pratique on est tranquilles : pour avoir une chance sur deux d’obtenir une collision, il faut générer <strong>1 milliard</strong> d’uuid4 par seconde…​ pendant 85 ans !</p>
</div>
<div class="paragraph">
<p>L’un des défauts des uuids, c’est que l’identifiant généré est long est pas très lisible : il est plus difficile de faire la différence entre <code>test_bbd5fbc0-f321-4b7c-93fb-0ff3bd927117</code> et <code>test_9f4cd855-0fab-499f-8920-a04c1a32eb10</code> qu’entre <code>test_23565</code> et <code>test_19901</code>. De plus, la génération de l’id peut-être plus longue :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight" style="background: #272822; color: #f8f8f2"><code data-lang="bash"><span></span><span style="color: #75715e"># uuid4 :</span>
python3 -m timeit --setup <span style="color: #e6db74">&#39;import uuid&#39;</span> <span style="color: #e6db74">&#39;uuid.uuid4()&#39;</span>
<span style="color: #ae81ff">100000</span> loops, best of <span style="color: #ae81ff">3</span>: <span style="color: #ae81ff">7</span>.35 usec per loop

<span style="color: #75715e"># randrange(24000) :</span>
python3 -m timeit --setup <span style="color: #e6db74">&#39;import random&#39;</span> <span style="color: #e6db74">&#39;random.randrange(24000)&#39;</span>
<span style="color: #ae81ff">1000000</span> loops, best of <span style="color: #ae81ff">3</span>: <span style="color: #ae81ff">1</span>.39 usec per loop</code></pre>
</div>
</div>
<div class="paragraph">
<p>Même si ce n’est pas ce que je recommande dans notre cas, ça reste une approche que j’aime bien.</p>
</div>
</div>
<div class="sect2">
<h3 id="_améliorer_la_façon_dont_on_tire">Améliorer la façon dont on tire</h3>
<div class="paragraph">
<p>Idéalement, au lieu de tirer un suffixe parmis tous ceux POSSIBLES, on devrait plutôt tirer un suffixe parmi tous ceux DISPONIBLES, à l’exclusion de ceux qui ont déjà été tirés.</p>
</div>
<div class="paragraph">
<p>Mais ça n’est pas toujours faisable, et même si c’est faisable, ça peut ne pas être très efficace : dans notre cas, il faudrait pouvoir interroger le serveur de base de données pour connaître les bases existantes, afin d’en choisir une libre.</p>
</div>
<div class="paragraph">
<p>Même dans ce cas, on a une race condition de type <a href="https://en.wikipedia.org/wiki/Time-of-check_to_time-of-use">TOCTOU</a> : entre le moment où on connaît les suffixes libres, et le moment où on en utlise un, un autre client pourra l’avoir consommé…​</p>
</div>
</div>
<div class="sect2">
<h3 id="_tirer_de_nouveau_si_nécessaire">Tirer de nouveau si nécessaire</h3>
<div class="paragraph">
<p>À défaut de pouvoir tirer le suffixe de façon idéale dès le début, on peut tirer de façon non-idéale, mais refaire le tirage si on tombe sur un suffixe déjà pris.</p>
</div>
<div class="paragraph">
<p>Ici aussi, l’approche n’est pas sans inconvénients : dans notre exemple ci-dessus, si jamais on se retrouve dans une situation où 990 clients ont utilisé un suffixe, on n’a plus que 1% de chances de tomber sur un suffixe libre. On se retrouverait alors à devoir refaire le tirage plusieurs fois (100 fois en moyenne) avant de tomber sur un suffixe libre.</p>
</div>
<div class="paragraph">
<p>Et même en tirant 100 fois, on a encore <a href="https://fr.wikipedia.org/wiki/Processus_de_Bernoulli">près de 40% de chances</a> de n’avoir toujours pas récupéré un suffixe disponible…​ Sans compter qu’on est confrontés au même TOCTOU que dans le paragraphe précédent.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_le_meilleur_code_est_celui_quon_nécrit_pas">Le meilleur code est celui qu’on n’écrit pas</h2>
<div class="sectionbody">
<div class="paragraph">
<p>La meilleure alternative à mes yeux est en fait d’éviter d’avoir à gérer soi-même le caractère temporaire de la base de données. Je n’ai pas l’impression qu’il soit possible de créer une <strong>base</strong> temporaire, mais <a href="https://www.postgresql.org/docs/12/sql-createtable.html">postgresql permet de créer des <strong>tables</strong> temporaires</a> :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight" style="background: #272822; color: #f8f8f2"><code data-lang="sql"><span></span><span style="color: #66d9ef">CREATE</span> <span style="color: #66d9ef">TEMPORARY</span> <span style="color: #66d9ef">TABLE</span> <span style="color: #f8f8f2">test</span> <span style="color: #f8f8f2">(</span> <span style="color: #f8f8f2">...</span> <span style="color: #f8f8f2">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Une telle table temporaire est propre à chaque session (inaccessible depuis une autre session), ce qui correspond exactement à notre besoin et nous garantit une absence de collision. On supprime par la même occasion les problèmes de TOCTOU mentionnés plus haut, et — cerise sur le gâteau — la table temporaire sera détruite une fois la session terminée, nous évitant ainsi de leaker des bases en cas d’exception ou de crash.</p>
</div>
<div class="paragraph">
<p>Pour illustrer cette approche, voici une deuxième situation très fréquente : la création d’un répertoire temporaire. Plutôt que de faire quelque chose comme :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight" style="background: #272822; color: #f8f8f2"><code data-lang="bash"><span></span><span style="color: #f8f8f2">my_temp_dir</span><span style="color: #f92672">=</span><span style="color: #e6db74">&#34;/tmp/test_</span><span style="color: #66d9ef">$(</span>uuid -v <span style="color: #ae81ff">4</span><span style="color: #66d9ef">)</span><span style="color: #e6db74">&#34;</span>
mkdir <span style="color: #f8f8f2">$my_temp_dir</span>
<span style="color: #75715e"># /tmp/test_45d06639-ff20-4ec8-88bd-228b77f60372</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Il vaut mieux utiliser <code>mktemp</code>, qui est fait pour ça :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight" style="background: #272822; color: #f8f8f2"><code data-lang="bash"><span></span><span style="color: #f8f8f2">my_temp_dir</span><span style="color: #f92672">=</span><span style="color: #e6db74">&#34;</span><span style="color: #66d9ef">$(</span>mktemp -d<span style="color: #66d9ef">)</span><span style="color: #e6db74">&#34;</span>
mkdir <span style="color: #f8f8f2">$my_temp_dir</span>
<span style="color: #75715e"># /tmp/tmp.wy1TxYKZLM</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>L’exemple ci-dessus est donné pour des scripts shell, mais la plupart des langages proposent un moyen de créer un répertoire temporaire, voire de le supprimer automatiquement : <a href="https://docs.python.org/3/library/tempfile.html">exemple en python</a>, <a href="https://docs.oracle.com/javase/7/docs/api/java/nio/file/Files.html#createTempDirectory%28java.nio.file.Path,%20java.lang.String,%20java.nio.file.attribute.FileAttribute…​%29">exemple en java</a>, …​</p>
</div>
<div class="paragraph">
<p>Petite astuce bash, c’est cadeau, ça me fait plaisir : même si <code>mktemp</code> se contente de <strong>créer</strong> une ressource temporaire, il reste possible de la <strong>supprimer</strong> automatiquement en sortie de script, avec <code>trap</code>, cf. <code>man bash</code> :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight" style="background: #272822; color: #f8f8f2"><code data-lang="bash"><span></span><span style="color: #75715e"># $my_temp_dir n&#39;a même pas besoin d&#39;être définie lorsqu&#39;on mets le trap</span>
<span style="color: #f8f8f2">trap</span> <span style="color: #e6db74">&#39;rm -rf &#34;$my_temp_dir&#34;&#39;</span> EXIT

<span style="color: #75715e"># ... du code ...</span>

<span style="color: #f8f8f2">my_temp_dir</span><span style="color: #f92672">=</span><span style="color: #e6db74">&#34;</span><span style="color: #66d9ef">$(</span>mktemp -d<span style="color: #66d9ef">)</span><span style="color: #e6db74">&#34;</span>

<span style="color: #75715e"># ... du code utilisant my_temp_dir ...</span>
<span style="color: #75715e"># my_temp_dir sera supprimé lorsque le script terminera, y compris en cas d&#39;exception, ou d&#39;erreur de syntaxe</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_pour_conclure">Pour conclure</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Comme d’habitude, il ne faut pas retenir de ce post les détails des calculs ou les propositions d’implémentations, mais plutôt l’idée générale, qu’on pourrait résumer en deux points :</p>
</div>
<div class="sect2">
<h3 id="_attention_aux_conclusions_hâtives">Attention aux conclusions hâtives</h3>
<div class="paragraph">
<p>Je parle des conclusions hâtives du genre de &#34;<em>en choisissant au hasard parmi 1000 valeurs possibles, je suis tranquille</em>&#34;.</p>
</div>
<div class="paragraph">
<p>Les probabilités sont parfois contre-intuitives, et elles dépendent fortement du contexte, notamment du nombre de tirages : une valeur pourra convenir lorsqu’il y a quelques exécutions concurrentes possibles, mais devenir inadaptée lorsqu’il y en a 50 ou 100.</p>
</div>
<div class="paragraph">
<p>Lorsque c’est possible — comme dans notre exemple — ne pas hésiter à calculer les probabilités exactes pour dimensionner l’ordre de grandeur de ses constantes.</p>
</div>
</div>
<div class="sect2">
<h3 id="_utiliser_ce_qui_existe">Utiliser ce qui existe</h3>
<div class="paragraph">
<p>Avant d’implémenter soi-même des outils de gestion de ressources temporaires, commencer par regarder si les outils ou langages utilisés n’en proposent pas <strong>déjà</strong>.</p>
</div>
<div class="paragraph">
<p>En fait, ce conseil s’applique plus généralement : je ne dis pas qu’on ne devrait jamais rien implémenter soi-même (surtout si ça permet d’éviter de créer une nouvelle dépendance), mais on devrait toujours avoir une solide raison de le faire plutôt que d’utiliser ce qui existe déjà.</p>
</div>
</div>
</div>
</div>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>

    

  </body>
</html>
