<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Phidra&#39;s blog</title>
    <link>https://phidra.github.io/blog/</link>
    <description>Recent content on Phidra&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>fr-fr</language>
    <lastBuildDate>Sun, 20 Dec 2020 11:00:00 +0100</lastBuildDate><atom:link href="https://phidra.github.io/blog/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Une &#34;super&#34; curiosité pythonique (ha ha)</title>
      <link>https://phidra.github.io/blog/2022-07-18-curiosite-pythonique-super/</link>
      <pubDate>Mon, 18 Jul 2022 10:00:00 +0100</pubDate>
      
      <guid>https://phidra.github.io/blog/2022-07-18-curiosite-pythonique-super/</guid>
      <description>Le présent post est très fortement inspiré par un exemple de cette vidéo sur super par mcoding.
   La curiosité Vous connaissez probablement super, qui permet de remplacer un appel explicite à une classe parente :
 # sans super : class BaseLogger: def log(self, msg: str): print(msg) class TimestampLogger(BaseLogger): def log(self, msg: str): timestamp = datetime.datetime.now().strftime(&amp;#34;%Y-%m-%d %H:%M:%S&amp;#34;) timestamped_msg = f&amp;#34;{timestamp} {msg}&amp;#34; BaseLogger.log(self, timestamped_msg) # &amp;lt;-- appel explicite à la classe parente # avec super : class BaseLogger: def log(self, msg: str): print(msg) class TimestampLogger(BaseLogger): def log(self, msg: str): timestamp = datetime.</description>
    </item>
    
    <item>
      <title>Node.js côté frontend ?!</title>
      <link>https://phidra.github.io/blog/2022-05-26-node-frontend/</link>
      <pubDate>Thu, 26 May 2022 10:00:00 +0100</pubDate>
      
      <guid>https://phidra.github.io/blog/2022-05-26-node-frontend/</guid>
      <description>Le web c’est simple Il y a bien longtemps, quand j’ai découvert le développement web frontend, mon modèle mental était simple :
   HTML décrit le contenu d’une page : un titre par-ci, un paragraphe par-là, un formulaire à deux boutons, …​
  CSS sert à styliser ledit contenu : le titre est en gras, le bouton Annuler en italique, …​
  JS permet d’exécuter du code côté client : e.</description>
    </item>
    
    <item>
      <title>Console, terminal, et shell</title>
      <link>https://phidra.github.io/blog/2021-11-14-console-terminal-shell/</link>
      <pubDate>Sun, 14 Nov 2021 10:00:00 +0100</pubDate>
      
      <guid>https://phidra.github.io/blog/2021-11-14-console-terminal-shell/</guid>
      <description>Si la notion de shell m’était à peu près claire, je n’avais jamais bien compris la différence entre terminal et console.
 Récemment, j’ai lu plusieurs articles qui m’ont éclairé sur le sujet (notamment cet excellent article) ; aujourd’hui, on va tenter de définir précisément ce que sont :
   console
  terminal
  teletype
  terminal vidéo
  virtual console
  terminal emulator</description>
    </item>
    
    <item>
      <title>from xxx import something</title>
      <link>https://phidra.github.io/blog/2021-10-03-from-xxx-import-something/</link>
      <pubDate>Sun, 03 Oct 2021 10:00:00 +0100</pubDate>
      
      <guid>https://phidra.github.io/blog/2021-10-03-from-xxx-import-something/</guid>
      <description>Une syntaxe confuse Un point m’a toujours chiffonné en python. Question simple :
 from xxx import something   C’est quoi exactement something ? Et où est le code importé ?
 TL;DR : on va voir que cette ligne peut importer trois types d’objets différents :
   le top-level objet something du module xxx
  le module something du package xxx
  le subpackage something du package xxx</description>
    </item>
    
    <item>
      <title>macros vim et commande :normal</title>
      <link>https://phidra.github.io/blog/2021-04-12-macros-vim-command-normal/</link>
      <pubDate>Mon, 12 Apr 2021 10:00:00 +0100</pubDate>
      
      <guid>https://phidra.github.io/blog/2021-04-12-macros-vim-command-normal/</guid>
      <description>préambule : ce post nécessite de connaître le principe des recordings vim, que j’appellerai macro dans la suite du post ; cf. :help recording.
   Unlimited poweeeeer ! Voici un combo génial de vim dont je viens d’apprendre la puissance :
 :normal! @a   Cette commande va appliquer la macro a sur la ligne courante. Joie. Bonheur. Extase.
 Pas convaincu ? Tu penses que tu aurais économisé des mouvements de doigts en te contentant de taper @a ?</description>
    </item>
    
    <item>
      <title>Boost Graph Library tutorial</title>
      <link>https://phidra.github.io/blog/2020-12-31-boost-graph-library/</link>
      <pubDate>Thu, 31 Dec 2020 10:00:00 +0100</pubDate>
      
      <guid>https://phidra.github.io/blog/2020-12-31-boost-graph-library/</guid>
      <description>Introduction  C’est subjectif, mais je trouve la doc de la Boost Graph Library (appelée BGL dans la suite de ce post) pas super bien foutue.
 J’ai récemment joué un peu avec, mon objectif était simple : créer le graphe suivant, et calculer le plus court chemin entre A et H avec l’algorithme de Dijkstra :
   Les lettres sont les vertex du graphe, les nombres au dessus des edges sont leur poids ; par conséquent, le plus court chemin entre A et H est ABEGH, de poids total 5+3+5+3=16.</description>
    </item>
    
    <item>
      <title>En deux mots</title>
      <link>https://phidra.github.io/blog/menu/in2words/</link>
      <pubDate>Sun, 20 Dec 2020 11:00:00 +0100</pubDate>
      
      <guid>https://phidra.github.io/blog/menu/in2words/</guid>
      <description>L’objectif de cette page est de &amp;#34;documenter&amp;#34; toutes les notions que je croise, liées de près ou de loin à mon métier.
 Je mets des guillemets autour de &amp;#34;documenter&amp;#34;, car il s’agit ici d’être concis : juste expliquer la notion en quelques mots, et éventuellement un ou deux pointeurs pour en apprendre plus.
 D’autres ressources sur internet ont la même vocation, et sont de BIEN meilleure qualité que cette page : elle a surtout de l’intérêt pour MOI, vu que c’est les notions que j’ai croisées MOI que je reporte ici, et que je les décris avec MES mots à moi, en y joignant les références que JE trouve pertinentes.</description>
    </item>
    
    <item>
      <title>Pas facile de rester concis</title>
      <link>https://phidra.github.io/blog/2020-12-05-pas-facile-de-rester-concis/</link>
      <pubDate>Sat, 05 Dec 2020 10:00:00 +0100</pubDate>
      
      <guid>https://phidra.github.io/blog/2020-12-05-pas-facile-de-rester-concis/</guid>
      <description>De l’idée au post Ça fait environ 10 mois que j’ai publié le premier post de ce blog. D’autres ont suivi, tous liés au développement logiciel ; le présent post sera le premier qui parlera d’autre chose.
 Même s’il n’est pas encore temps de faire un bilan ni de comparer mon expérience à ce que j’en attendais, je veux réfléchir dès maintenant à ma façon de blogger, et notamment à une question précise, que je formule un peu plus bas.</description>
    </item>
    
    <item>
      <title>Saut de ligne en fin de fichier</title>
      <link>https://phidra.github.io/blog/2020-11-20-saut-de-ligne-final/</link>
      <pubDate>Fri, 20 Nov 2020 10:00:00 +0100</pubDate>
      
      <guid>https://phidra.github.io/blog/2020-11-20-saut-de-ligne-final/</guid>
      <description>Tout commence en parsant du CSV Récemment, j’ai eu à parser un fichier CSV en C++. C’est souvent une fausse bonne idée de parser soi-même du CSV, car c’est plus compliqué qu’il n’y paraît, mais là ça s’y prêtait bien.
 J’ai écrit quelque chose comme :
 #include &amp;lt;sstream&amp;gt; #include &amp;lt;vector&amp;gt; using namespace std; vector&amp;lt;string&amp;gt; parse(istream&amp;amp; stream) { vector&amp;lt;string&amp;gt; tokens; string line; while(getline(stream, line).good()) { tokens.push_back(line); } return tokens; } int main(void) { istringstream iss(&amp;#34;line1\nline2\n&amp;#34;); parse(iss); // {&amp;#34;line1&amp;#34;, &amp;#34;line2&amp;#34;} }   Et ce code fonctionne correctement…​ ou presque : en testant quelques entrées différentes, on observe un comportement curieux : lorsque la chaîne (ou le contenu du fichier) n’a pas de saut de ligne final (\n), la dernière ligne est ignorée :</description>
    </item>
    
    <item>
      <title>Où linker ses librairies</title>
      <link>https://phidra.github.io/blog/2020-11-03-linker-options-order/</link>
      <pubDate>Tue, 03 Nov 2020 10:00:00 +0100</pubDate>
      
      <guid>https://phidra.github.io/blog/2020-11-03-linker-options-order/</guid>
      <description>Mise en situation Allez, pour une fois, on attaque cash pistache avec du code :
 #include &amp;lt;iostream&amp;gt; #include &amp;lt;zlib.h&amp;gt; int main(void) { std::cout &amp;lt;&amp;lt; &amp;#34;zlib version = &amp;#34; &amp;lt;&amp;lt; zlibVersion() &amp;lt;&amp;lt; std::endl; return 0; }   On a un main.cpp qui utilise une librairie, en l’occurence la zlib ; la question du jour concerne la commande à utiliser pour le builder. On trouve parfois ce type de commande :</description>
    </item>
    
    <item>
      <title>Un usage de std::ref</title>
      <link>https://phidra.github.io/blog/2020-08-31-std-ref/</link>
      <pubDate>Mon, 31 Aug 2020 10:00:00 +0100</pubDate>
      
      <guid>https://phidra.github.io/blog/2020-08-31-std-ref/</guid>
      <description>Je repars aujourd’hui de ce post sur std::reference_wrapper, pour expliquer l’intérêt de std::ref dans les appels de fonctions template.
 Dans un précédent post, on a lancé un calcul lourd dans un thread détaché du thread principal comme ceci :
 void heavy_task(int&amp;amp; result, const int amount) { /* ... */ } int main(void) { int result_even = 0; auto th = std::thread(heavy_task, std::ref(result_even), amount); }   On s’intéresse à std::ref(result_even) : qu’apporte std::ref, et pourquoi est-il nécessaire ici ?</description>
    </item>
    
    <item>
      <title>Bash et les nested quotes</title>
      <link>https://phidra.github.io/blog/2020-08-19-nested-quotes-in-bash/</link>
      <pubDate>Wed, 19 Aug 2020 10:00:00 +0100</pubDate>
      
      <guid>https://phidra.github.io/blog/2020-08-19-nested-quotes-in-bash/</guid>
      <description>Pourquoi mettre des quotes Même s’ils sont bien pratiques car utilisables presque partout et proches du système, dès que j’ai un besoin complexe, je préfère éviter les scripts bash.
 L’une des raisons à cela est que la gestion des chaînes de caractères est bug-prone. Prenons l’exemple d’un fichier dans un répertoire, avec les deux noms contenant un espace :
 mkdir &amp;#34;this directory&amp;#34; myfile=&amp;#34;this directory/that file.txt&amp;#34; touch &amp;#34;$myfile&amp;#34; tree # .</description>
    </item>
    
    <item>
      <title>Application pratique du paradoxe des anniversaires</title>
      <link>https://phidra.github.io/blog/2020-08-08-birthday-problem/</link>
      <pubDate>Sat, 08 Aug 2020 10:00:00 +0100</pubDate>
      
      <guid>https://phidra.github.io/blog/2020-08-08-birthday-problem/</guid>
      <description>Création d’une base temporaire Lors d’une revue de code, je suis tombé récemment sur la création d’une base de données temporaire :
 db_name = &amp;#34;test_{}&amp;#34;.format(randrange(1000))   Le contexte : un test a besoin d’une base de données vierge, il créée donc une base temporaire dont le nom est celui de la ligne ci-dessus, puis la supprime après utilisation. Le sujet qui nous intéresse aujourd’hui : pour s’assurer sans trop d’effort que des exécutions concurrentes du test ne se marcheront pas dessus, le nom de la base temporaire comporte un suffixe aléatoire : randrange(1000).</description>
    </item>
    
    <item>
      <title>Concurrence et parallélisme</title>
      <link>https://phidra.github.io/blog/2020-06-09-concurrency-vs-parallelism/</link>
      <pubDate>Tue, 09 Jun 2020 10:00:00 +0100</pubDate>
      
      <guid>https://phidra.github.io/blog/2020-06-09-concurrency-vs-parallelism/</guid>
      <description>Concurrence == parallélisme ? À l’oral, on mélange souvent concurrence et parallélisme. D’ailleurs, en première approche, à la question &amp;#34;C’est quoi un programme qui exécute des tâches concurrentes ?&amp;#34;, on serait tenté de répondre :
  — C’est un programme qui exécute plusieurs tâches en même temps.
   Et à la question &amp;#34;C’est quoi un programme qui exécute des tâches en parallèle ?&amp;#34;, on peut également fournir la même réponse :</description>
    </item>
    
    <item>
      <title>R-tree et applications</title>
      <link>https://phidra.github.io/blog/2020-05-01-rtree/</link>
      <pubDate>Fri, 01 May 2020 10:00:00 +0100</pubDate>
      
      <guid>https://phidra.github.io/blog/2020-05-01-rtree/</guid>
      <description>Une histoire de graphe Supposons qu’on veuille implémenter un calculateur d’itinéraire permettant de retrouver le plus court chemin entre deux lieux quelconques de Bordeaux. Par exemple, on veut trouver le plus court chemin entre la place de la Victoire et &amp;#34;chez moi&amp;#34;.
 Pour cela, on dispose d’une liste de toutes les rues de Bordeaux, accompagnées de leur géométrie. La géométrie d’une rue est vue comme une liste de N segments consécutifs, donc une liste de N+1 points GPS.</description>
    </item>
    
    <item>
      <title>Packaging python</title>
      <link>https://phidra.github.io/blog/2020-03-17-packaging-python/</link>
      <pubDate>Tue, 17 Mar 2020 22:14:41 +0100</pubDate>
      
      <guid>https://phidra.github.io/blog/2020-03-17-packaging-python/</guid>
      <description>Comme beaucoup (beaucoup) d’autres avant moi, je blogge sur le packaging python.
 Je ne vais pas cependant PAS expliquer comment packager son projet (ou pas beaucoup, et ça restera facultatif ^^). À la place, je vais essayer d’expliquer grossièrement ce dont on parle quand on s’intéresse au packaging, et clarifier une confusion fréquente — en tout cas que j’ai faite moi.
 Ce post n’est donc pas suffisant pour naviguer comme un poisson dans les eaux du packaging python, l’objectif est plutôt d’en sortir un peu mieux armé pour utiliser les autres ressources sur le sujet : docs, articles, tutos, etc.</description>
    </item>
    
    <item>
      <title>Qu&#39;est-ce qui fait une équipe efficace ?</title>
      <link>https://phidra.github.io/blog/2020-03-11-aristotle-project/</link>
      <pubDate>Wed, 11 Mar 2020 10:00:00 +0100</pubDate>
      
      <guid>https://phidra.github.io/blog/2020-03-11-aristotle-project/</guid>
      <description>Si on vous posait la question, qu’est-ce que vous répondriez ? Pour ma part, j’aurais sans doute avancé des éléments comme :
   des membres compétents
  des membres qui s’entendent bien
  un niveau technique homogène (ou au contraire disparate ?)
  des membres qui savent travailler en équipe (ça veut dire quoi, ça, d’ailleurs ?)
  une équipe à taille humaine
  …​</description>
    </item>
    
    <item>
      <title>Shuffle, Fisher-Yates, et Sattolo</title>
      <link>https://phidra.github.io/blog/2020-02-28-shuffle/</link>
      <pubDate>Fri, 28 Feb 2020 10:00:00 +0100</pubDate>
      
      <guid>https://phidra.github.io/blog/2020-02-28-shuffle/</guid>
      <description>Position du problème Je suis tombé sur un article très intéressant, j’avais commencé à prendre des notes, mais ça se finit en post :-)
 Étant donné un jeu de N cartes, comment le mélanger de telle sorte que chaque permutation possible ait la même probabilité d’être choisie ?
 Exemple concret : prenons un jeu de 5 cartes ABCDE :
  Figure 1. Jeu de 5 cartes  L’objectif final est de le mélanger :</description>
    </item>
    
    <item>
      <title>RTFM ?</title>
      <link>https://phidra.github.io/blog/2020-02-20-man/</link>
      <pubDate>Thu, 20 Feb 2020 10:00:00 +0100</pubDate>
      
      <guid>https://phidra.github.io/blog/2020-02-20-man/</guid>
      <description>Position du problème La plupart du temps, quand j’utilise man, je m’embête pas, et je fais par exemple :
 man tar   Mais on trouve de temps à autre une syntaxe précisant un numéro, assortie parfois d’une vague mention de &amp;#34;sections&amp;#34;. Par exemple :
 man 3 zlib   J’avais toujours supposé sans jamais le vérifier que ces commandes avaient leur manuel découpé en plusieurs &amp;#34;chapitres&amp;#34;, et que ce numéro était le numéro du chapitre : man 3 zlib était équivalent à ouvre le troisième chapitre du man de zlib.</description>
    </item>
    
    <item>
      <title>Intérêt de make_shared</title>
      <link>https://phidra.github.io/blog/2020-02-15-make_shared/</link>
      <pubDate>Fri, 14 Feb 2020 15:08:25 +0100</pubDate>
      
      <guid>https://phidra.github.io/blog/2020-02-15-make_shared/</guid>
      <description>Ça sert à quoi make_shared ? Quel est l’intérêt de make_shared ? Après tout, on peut très bien s’en passer pour créer des shared_ptr :
 shared_ptr&amp;lt;int&amp;gt; age{new int(42)};   Par rapport à la ligne qui précède, quelle est la valeur ajoutée de la ligne suivante :
 shared_ptr&amp;lt;int&amp;gt; age = make_shared&amp;lt;int&amp;gt;(42);   TL;DR : c’est plus un peu plus efficace, et un peu moins risqué.
   Mais au fait, ça marche comment, shared_ptr ?</description>
    </item>
    
    <item>
      <title>Articles, talks, blogposts, et autres liens</title>
      <link>https://phidra.github.io/blog/menu/notes/</link>
      <pubDate>Wed, 01 Jan 2020 12:00:00 +0100</pubDate>
      
      <guid>https://phidra.github.io/blog/menu/notes/</guid>
      <description>EDIT 2021-02-26 : pour diverses raisons expliquées plus bas, mes notes seront dorénavant prise sur ce repo github, et la présente page ne sera plus alimentée.
   Liste des liens  
   
   Pourquoi cette page Je croise souvent des articles/vidéos/posts/etc. dont j’ai envie de garder quelque chose. Jusqu’ici, ma façon canonique de le faire était d’en &amp;#34;extraire&amp;#34; la connaissance et de trouver un endroit dans mes notes où l’ajouter.</description>
    </item>
    
    <item>
      <title>Mes références</title>
      <link>https://phidra.github.io/blog/menu/references/</link>
      <pubDate>Wed, 01 Jan 2020 11:00:00 +0100</pubDate>
      
      <guid>https://phidra.github.io/blog/menu/references/</guid>
      <description>Work in progress → liste non-exhaustive.
 Elle n’est pas particulièrement triée : c’est pas parce qu’un item est en haut que je le juge plus intéressant que son voisin du dessous.
   Sources   Sam &amp;amp; Max : on ne les présente plus. Si ? C’est l’une des ressources francophones sur python des plus pédagogiques, très accessibles aux débutants. Le blog est freezé mais reste en ligne, c’est l’une des références qui m’a donnée envie de blogger.</description>
    </item>
    
    <item>
      <title>À propos</title>
      <link>https://phidra.github.io/blog/menu/about/</link>
      <pubDate>Wed, 01 Jan 2020 10:00:00 +0100</pubDate>
      
      <guid>https://phidra.github.io/blog/menu/about/</guid>
      <description>Quoi Je suis Phidra, développeur depuis une douzaine d’années → ce blog contient des posts liés au développement, surtout en C++ (e.g. utilité de make_shared) et en python (e.g. le packaging python) qui sont mes langages principaux, mais également des structures de données (e.g. le rtree) ou algorithmes (e.g. l’algorithme de Sattolo), des outils (e.g. les sections de man), voire des sujets liés à la vie de développeur (e.g. le projet Aristote).</description>
    </item>
    
  </channel>
</rss>
