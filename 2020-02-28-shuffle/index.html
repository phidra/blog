<!doctype html>
<html lang="fr-fr">
  <head>
    <title>Shuffle, Fisher-Yates, et Sattolo // Phidra&#39;s blog</title>
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.81.0-DEV" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    
    <meta name="author" content="phidra" />
    

    
    <meta name="description" content="blog tech C&#43;&#43; python dev" />
    

    <link rel="stylesheet" href="https://phidra.github.io/blog/css/main.min.7a031c63f91e76e2f20780fa544c7984e864efc78057fa7ad2792849259c0d15.css" />

    

    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  </head>
  <body>
    <header class="app-header">

      
      
      <a href="https://phidra.github.io/blog/" id="avatar">
          <img src="/blog/img/general/phi_medium_fond_blanc.png" alt="phidra" />
      </a>
      

      <a href="https://phidra.github.io/blog/">
        <h1 class="title">Phidra&#39;s blog</h1>
      </a>

      
      <input class="burger" type="checkbox">
      <nav>
        <a href="https://phidra.github.io/blog/">                <i class="material-icons"> home </i>Posts       </a>
        <a href="https://phidra.github.io/blog/menu/notes/">      <i class="material-icons"> event_note </i>Notes       </a>
        <a href="https://phidra.github.io/blog/menu/references/"> <i class="material-icons"> menu_book </i>Références  </a>
        <a href="https://phidra.github.io/blog/menu/in2words/"> <i class="material-icons"> school </i>En 2 mots  </a>
        <a href="https://phidra.github.io/blog/menu/about/">      <i class="material-icons"> info </i>À propos    </a>
      </nav>

    </header>

    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">Shuffle, Fisher-Yates, et Sattolo</h1>
      <div class="post-meta">
        <div>
          Feb 28, 2020
          —
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          9 min read
        </div></div>
    <div>
        <nav id="TableOfContents"></nav>
    </div>
    </header>
    <div class="post-content">
      <div class="sect1">
<h2 id="_position_du_problème">Position du problème</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Je suis tombé sur un <a href="https://danluu.com/sattolo/">article très intéressant</a>, j’avais commencé à prendre des notes, mais ça se finit en post :-)</p>
</div>
<div class="paragraph">
<p>Étant donné un jeu de N cartes, comment le mélanger de telle sorte que chaque permutation possible ait la même probabilité d’être choisie ?</p>
</div>
<div class="paragraph">
<p>Exemple concret : prenons un jeu de 5 cartes ABCDE :</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="../2020-02-28-shuffle-img/blank.svg" alt="blank"/>
</div>
<div class="title">Figure 1. Jeu de 5 cartes</div>
</div>
<div class="paragraph">
<p>L’objectif final est de le mélanger :</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="../2020-02-28-shuffle-img/permutated-noncyclic.svg" alt="permutated noncyclic"/>
</div>
<div class="title">Figure 2. Le même jeu, mélangé</div>
</div>
<div class="paragraph">
<p>La permutation correspondant au mélange précédent est la suivante :</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="../2020-02-28-shuffle-img/noncyclic.svg" alt="noncyclic"/>
</div>
<div class="title">Figure 3. La permutation</div>
</div>
<div class="paragraph">
<p><strong>TL;DR :</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>attention : une implémentation naïve serait biaisée, et toutes les permutations possibles ne seraient pas équi-probables</p>
</li>
<li>
<p>l’algorithme de Fisher-Yates est une implémentation correcte de ce point de vue</p>
</li>
<li>
<p>l’algorithme de Sattolo est à utiliser lorsqu’on veut une permutation cyclique</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_implémentation_naïve">Implémentation naïve</h2>
<div class="sectionbody">
<div class="paragraph">
<p>En première approche, on serait tenté d’itérer sur chaque carte de l’array, et de la swapper avec une carte au hasard dans l’array :</p>
</div>
<div class="listingblock">
<div class="title">Implémentation naïve</div>
<div class="content">
<pre class="pygments highlight" style="background: #272822; color: #f8f8f2"><code data-lang="python"><span></span><span style="color: #66d9ef">def</span> <span style="color: #a6e22e">shuffle</span><span style="color: #f8f8f2">(array):</span>
    <span style="color: #f8f8f2">n</span> <span style="color: #f92672">=</span> <span style="color: #f8f8f2">len(array)</span>
    <span style="color: #75715e"># on itère sur chaque carte :</span>
    <span style="color: #66d9ef">for</span> <span style="color: #f8f8f2">i</span> <span style="color: #f92672">in</span> <span style="color: #f8f8f2">range(n</span> <span style="color: #f92672">-</span> <span style="color: #ae81ff">1</span><span style="color: #f8f8f2">):</span>
        <span style="color: #75715e"># pour chacune, on choisit une autre carte avec laquelle swapper :</span>
        <span style="color: #f8f8f2">swapped</span> <span style="color: #f92672">=</span> <span style="color: #f8f8f2">random</span><span style="color: #f92672">.</span><span style="color: #f8f8f2">randrange(</span><span style="color: #ae81ff">0</span><span style="color: #f8f8f2">,</span> <span style="color: #f8f8f2">n)</span>
        <span style="color: #f8f8f2">array[i],</span> <span style="color: #f8f8f2">array[swapped]</span> <span style="color: #f92672">=</span> <span style="color: #f8f8f2">array[swapped],</span> <span style="color: #f8f8f2">array[i]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Le problème de cette implémentation, c’est que certaines permutations ont plus de chances d’être retenues que d’autres : le caractère aléatoire du mélange est biaisé.</p>
</div>
<div class="paragraph">
<p> </p><details><summary> 
Explications sur le caractère non-équi-probable des permutations
 </summary><div> <p></p>
</div>
<div class="sect2">
<h3 id="_ma_compréhension_du_problème_avec_les_mains">Ma compréhension du problème avec les mains</h3>
<div class="paragraph">
<p>Avec les mains (je suis très attaché aux explications avec les mains), on va regarder le fonctionnement de l’algo à rebours, pour montrer que toutes les cartes n’ont pas la même probabilité d’arriver en dernière position :</p>
</div>
<div class="ulist">
<ul>
<li>
<p>lorsque l’algo est sur le point d’effectuer sa dernière itération (il cherche à positionner la carte actuellement placée en fin de tableau, qu’on va appeler <strong>C<sub>N</sub></strong>), <strong>C<sub>N</sub></strong> a autant de chances de se retrouver dans chacune des cases du tableau. Dit autrement, la position finale de <strong>C<sub>N</sub></strong> dans l’array renvoyé sera choisie <span class="underline">de façon uniforme</span> entre les N cases du tableau.</p>
</li>
<li>
<p>(à noter que dans le cas général, <strong>C<sub>N</sub></strong> n’est pas la dernière carte du tableau passé en entrée, vu qu’une autre carte a pu y être placée entretemps : c’est la dernière carte <span class="underline">au moment de la dernière itération</span>)</p>
</li>
<li>
<p>on continue à fonctionner à rebours : lorsque l’algo en est à son avant-dernière itération, la position de <strong>C<sub>N-1</sub></strong> sera, elle aussi, choisie de façon équi-probable parmi toutes les cases du tableau :</p>
<div class="ulist">
<ul>
<li>
<p>si jamais <strong>C<sub>N-1</sub></strong> est attribuée aux N-1 premières cases, tout va bien</p>
</li>
<li>
<p>MAIS si jamais <strong>C<sub>N-1</sub></strong> se retrouve attribuée à la dernière case du tableau, alors à l’itération d’après, elle sera DEVENUE <strong>C<sub>N</sub></strong>, et sera donc sans doute déplacée ailleurs !</p>
</li>
</ul>
</div>
</li>
<li>
<p>dit autrement, la carte qui était à l’avant-dernière position au moment de l’avant-dernière itération aura MOINS de chances de finir sur la dernière case que sur les autres !</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_une_preuve_un_peu_plus_formelle_par_labsurde">Une preuve (un peu) plus formelle par l’absurde</h3>
<div class="ulist">
<ul>
<li>
<p>il existe <strong>N!</strong> permutations différentes de l’array initial</p>
</li>
<li>
<p>en fonction des N résultats des tirages aléatoires <code>randrange(0, n)</code> l’algo naïf peut produire <strong>N<sup>N</sup></strong> permutations différentes, en effet :</p>
<div class="ulist">
<ul>
<li>
<p>on a <strong>N</strong> positions possibles pour le shuffle de la PREMIÈRE carte</p>
</li>
<li>
<p>puis, on a de nouveau <strong>N</strong> positions possibles pour le shuffle de la SECONDE carte</p>
</li>
<li>
<p>etc. jusqu’à ce qu’on ait mélangé chacune des <strong>N</strong> cartes</p>
</li>
</ul>
</div>
</li>
<li>
<p>comme <strong>N<sup>N</sup> &gt; N!</strong>, fatalement, il existera des jeux de tirages aléatoires différents qui produiront des permutations finales de l’array <em>identiques</em></p>
</li>
<li>
<p>si l’algo naïf était uniforme,, les <strong>N<sup>N</sup></strong> permutations produites par l’algo se répartiraient équitablement entre les <strong>N!</strong> permutations possibles, ce qui est impossible car dans le cas général, <strong>N<sup>N</sup></strong> n’est pas divisible par <strong>N!</strong></p>
</li>
</ul>
</div>
<div class="paragraph">
<p> </p></div></div></details> <p></p>
</div>
<div class="paragraph">
<p>Ces explications ne sont pas indispensables pour la suite, vous pouvez allègrement les ignorer et passer directement à la suite.</p>
</div>
</div>
</div>

<div class="sect1">
<h2 id="_lalgorithme_de_fisher_yates">L’algorithme de Fisher-Yates</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Un algo qui produit des permutations équi-probables est <a href="https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle">l’algorithme de Fisher-Yates</a> :</p>
</div>
<div class="listingblock">
<div class="title">Fisher-Yates</div>
<div class="content">
<pre class="pygments highlight" style="background: #272822; color: #f8f8f2"><code data-lang="python"><span></span><span style="color: #66d9ef">def</span> <span style="color: #a6e22e">shuffle</span><span style="color: #f8f8f2">(array):</span>
    <span style="color: #f8f8f2">n</span> <span style="color: #f92672">=</span> <span style="color: #f8f8f2">len(array)</span>
    <span style="color: #66d9ef">for</span> <span style="color: #f8f8f2">i</span> <span style="color: #f92672">in</span> <span style="color: #f8f8f2">range(n</span> <span style="color: #f92672">-</span> <span style="color: #ae81ff">1</span><span style="color: #f8f8f2">):</span>
        <span style="color: #f8f8f2">swapped</span> <span style="color: #f92672">=</span> <span style="color: #f8f8f2">random</span><span style="color: #f92672">.</span><span style="color: #f8f8f2">randrange(i,</span> <span style="color: #f8f8f2">n)</span>  <span style="color: #75715e"># &lt;--</span>
        <span style="color: #f8f8f2">array[i],</span> <span style="color: #f8f8f2">array[swapped]</span> <span style="color: #f92672">=</span> <span style="color: #f8f8f2">array[swapped],</span> <span style="color: #f8f8f2">array[i]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Et je vous entends déjà crier que c’est le même algo. Ben non ! C’est subtil, mais :</p>
</div>
<div class="listingblock">
<div class="title">Fisher-Yates, ce qui change</div>
<div class="content">
<pre class="pygments highlight" style="background: #272822; color: #f8f8f2"><code data-lang="python"><span></span><span style="color: #75715e"># la borne inf du randrange est i, pas 0 :</span>
<span style="color: #f8f8f2">swapped</span> <span style="color: #f92672">=</span> <span style="color: #f8f8f2">random</span><span style="color: #f92672">.</span><span style="color: #f8f8f2">randrange(i,</span> <span style="color: #f8f8f2">n)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>C’est une petite modification, mais ça change tout !</p>
</div>
<div class="paragraph">
<p>J’aime bien voir les choses comme ça, avec l’algorithme de Fisher-Yates :</p>
</div>
<div class="ulist">
<ul>
<li>
<p>on itère sur les emplacements libres, et on attribue à chacun une carte au hasard parmi celles restantes</p>
</li>
<li>
<p>à chaque itération, la carte mise à l’emplacement l’est <strong>définitivement</strong> : elle ne sera plus déplacée par la suite</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Alors qu’avec l’implémentation naïve, on avait plutôt :</p>
</div>
<div class="ulist">
<ul>
<li>
<p>on itère sur les cartes, et on va leur attribuer un emplacement au hasard</p>
</li>
<li>
<p>à chaque itération, la carte mise à l’emplacement <strong>peut encore être déplacée</strong> par les itérations suivantes</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Et ce coup-ci, les différentes permutations produites par l’algorithme sont équi-probables.</p>
</div>
<div class="paragraph">
<p> </p><details><summary> 
Explications sur le caractère équi-probable des permutations
 </summary><div> <p></p>
</div>
<div class="paragraph">
<p>Combien de permutations différentes l’algorithme de Fisher-Yates peut-il produire ?</p>
</div>
<div class="ulist">
<ul>
<li>
<p>on a <strong>N</strong> cartes possibles pour le choix de la carte qui finira en PREMIÈRE position</p>
</li>
<li>
<p>puis, il reste <strong>N-1</strong> cartes possibles pour le choix de la carte qui finira en SECONDE position</p>
</li>
<li>
<p>etc.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Au final, l’algorithme de Fisher-Yates peut produire <strong>N!</strong> permutations.</p>
</div>
<div class="paragraph">
<p>On produit donc bien chacune des <strong>N!</strong> permutations possibles, et comme les permutations produites sont toutes différentes, elles sont équi-probables.</p>
</div>
<div class="paragraph">
<p> </p></div></details> <p></p>
</div>
<div class="paragraph">
<p>C’est cet algorithme qui est par exemple <a href="https://github.com/python/cpython/blob/041d8b48a2e59fa642b2c5124d78086baf74e339/Lib/random.py#L304">utilisé par l’implémentation python de shuffle</a> (sauf que l’array final est rempli en commençant par la fin,  mais ça ne change rien au schmilblick).</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_allons_plus_loin_algorithme_de_sattolo">Allons plus loin : algorithme de Sattolo</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_les_permutations_cycliques">Les permutations cycliques</h3>
<div class="paragraph">
<p>Pour parler un peu de Sattolo, on va s’intéresser à certaines permutations particulières, les <a href="https://en.wikipedia.org/wiki/Cyclic_permutation">permutations cycliques</a>.</p>
</div>
<div class="paragraph">
<p>Reprenons notre jeu de 5 cartes et sa permutation:</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="../2020-02-28-shuffle-img/noncyclic.svg" alt="noncyclic"/>
</div>
<div class="title">Figure 4. Permutation du jeu de 5 cartes</div>
</div>
<div class="paragraph">
<p>On peut s’intéresser à ce qui se passe lorsqu’on part d’une case (par exemple <code>A</code>) et qu’on suit les flèches rouges.</p>
</div>
<div class="paragraph">
<p>Par exemple, si on part de <code>A</code>, on produit la sortie <code>A &gt; B &gt; C &gt; A &gt; B &gt; C &gt; A …​</code>.</p>
</div>
<div class="paragraph">
<p>Et si on part de <code>E</code>, on produit la sortie <code>E &gt; D &gt; E &gt; …​</code>.</p>
</div>
<div class="paragraph">
<p>En y regardant de plus près, on voit donc que cette permutation est en fait constituée de deux sous-permutations indépendantes : <code>A &gt; B &gt; C</code> qui mélange les 3 premières cartes, et <code>D &gt; E</code> qui mélange les 2 dernières.</p>
</div>
<div class="paragraph">
<p>Il existe pourtant des permutations &#34;d’un seul tenant&#34;, comme celle-ci :</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="../2020-02-28-shuffle-img/cyclic.svg" alt="cyclic"/>
</div>
<div class="title">Figure 5. Permutation &#34;d’un seul tenant&#34;</div>
</div>
<div class="paragraph">
<p>Ici, quelle que soit la lettre de départ, si on suit les flèches rouges, on va parcourir <strong>TOUTES</strong> les lettres de l’array avant de revenir sur la lettre de départ.</p>
</div>
<div class="paragraph">
<p>Par exemple avec <code>A</code>, on produit la sortie <code>A &gt; B &gt; C &gt; E &gt; D &gt; A &gt; …​</code>.</p>
</div>
<div class="paragraph">
<p>Ce sont ces permutations &#34;d’un seul tenant&#34; qu’on appelle des permutations cycliques.</p>
</div>
<div class="paragraph">
<p>Note : lorsqu’on calcule une permutation quelconque, chaque carte peut se retrouver n’importe où, et a donc une petite chance de se retrouver sur sa case initiale. Ainsi, même si elle n’a qu’une chance sur 120 (= <strong>5!</strong>) d’arriver, la permutation produite par l’algorithme de Fisher-Yates pourrait tout à fait être la suivante, qui ne mélange pas le jeu :</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="../2020-02-28-shuffle-img/identity.svg" alt="identity"/>
</div>
<div class="title">Figure 6. Permutation &#34;identité&#34;</div>
</div>
<div class="paragraph">
<p>À l’inverse, une permutation cyclique garantit que chaque carte finira sur une case différente de sa case initiale.</p>
</div>
</div>
<div class="sect2">
<h3 id="_et_sattolo_dans_tout_ça">Et Sattolo dans tout ça ?</h3>
<div class="paragraph">
<p>L’algorithme de Sattolo, ressemble beaucoup à l’algorithme de Fisher-Yates, mais ne produit QUE des permutations cycliques :</p>
</div>
<div class="listingblock">
<div class="title">Algorithme de Sattolo</div>
<div class="content">
<pre class="pygments highlight" style="background: #272822; color: #f8f8f2"><code data-lang="python"><span></span><span style="color: #66d9ef">def</span> <span style="color: #a6e22e">shuffle</span><span style="color: #f8f8f2">(array):</span>
    <span style="color: #f8f8f2">n</span> <span style="color: #f92672">=</span> <span style="color: #f8f8f2">len(array)</span>
    <span style="color: #66d9ef">for</span> <span style="color: #f8f8f2">i</span> <span style="color: #f92672">in</span> <span style="color: #f8f8f2">range(n</span> <span style="color: #f92672">-</span> <span style="color: #ae81ff">1</span><span style="color: #f8f8f2">):</span>
        <span style="color: #f8f8f2">swapped</span> <span style="color: #f92672">=</span> <span style="color: #f8f8f2">random</span><span style="color: #f92672">.</span><span style="color: #f8f8f2">randrange(i</span> <span style="color: #f92672">+</span> <span style="color: #ae81ff">1</span><span style="color: #f8f8f2">,</span> <span style="color: #f8f8f2">n)</span>  <span style="color: #75715e"># &lt;--</span>
        <span style="color: #f8f8f2">array[i],</span> <span style="color: #f8f8f2">array[swapped]</span> <span style="color: #f92672">=</span> <span style="color: #f8f8f2">array[swapped],</span> <span style="color: #f8f8f2">array[i]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><span class="line-through">Et je vous entends déjà crier que c’est le même algo</span> Bon je refais pas mon laïus, ce qui change, c’est :</p>
</div>
<div class="listingblock">
<div class="title">Algorithme de Sattolo, ce qui change</div>
<div class="content">
<pre class="pygments highlight" style="background: #272822; color: #f8f8f2"><code data-lang="python"><span></span><span style="color: #75715e"># la place actuelle ne peut PAS se voir attribuée la carte déjà dessus :</span>
<span style="color: #f8f8f2">swapped</span> <span style="color: #f92672">=</span> <span style="color: #f8f8f2">random</span><span style="color: #f92672">.</span><span style="color: #f8f8f2">randrange(i</span> <span style="color: #f92672">+</span> <span style="color: #ae81ff">1</span><span style="color: #f8f8f2">,</span> <span style="color: #f8f8f2">n)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Le truc cool : non seulement l’algo ne génère <strong>QUE</strong> des permutations cycliques, mais de plus, celles-ci sont équi-probables \o/</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_références">Références :</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><a href="http://danluu.com/sattolo/">l’article qui a donné naissance à ce post</a></p>
</li>
<li>
<p><a href="https://blog.codinghorror.com/the-danger-of-naivete/">un post de Jeff ATWOOD sur l’algorithme de Fisher-Yates vs. l’implémentation naïve</a></p>
</li>
<li>
<p><a href="https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle">la page wikipedia sur l’algorithme de Fisher-Yates, bien fournie</a></p>
</li>
<li>
<p><a href="https://en.wikipedia.org/wiki/Cyclic_permutation">la page wikipedia sur les permutations cycliques</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Dans l’article qui a inspiré ce post, Dan LUU présente les permutations cycliques d’une façon différente, que j’avais initialement reprise à mon compte, avant de choisir de les illustrer autrement :</p>
</div>
<div class="paragraph">
<p> </p><details><summary> 
Visualiser les permutations cycliques à partir d’un tableau trié
 </summary><div> <p></p>
</div>
<div class="paragraph">
<p>Prenons un array quelconque de N entiers (compris entre 0 et N-1), on va supposer qu’on peut le &#34;parcourir&#34; de la façon suivante :</p>
</div>
<div class="ulist">
<ul>
<li>
<p>la case de départ est la case d’indice 0</p>
</li>
<li>
<p>la case suivante est la case dont l’indice est donné par le <strong>contenu</strong> de la case 0</p>
</li>
<li>
<p>etc. : à chaque itération, la case vers laquelle on se déplace est le <strong>contenu</strong> de la case actuelle</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>(notez qu’on n’est pas obligés de commencer sur la case 0, mais que ça facilite le raisonnement)</p>
</div>
<div class="paragraph">
<p>Comme il y a N cases qui contiennent des entiers entre 0 et N-1, on va forcément finir par retomber sur une case déjà visitée, et le parcours dont il est question est en fait cyclique.</p>
</div>
<div class="paragraph">
<p>Par exemple, l’array suivant :</p>
</div>
<div class="literalblock">
<div class="content">
<pre>40123</pre>
</div>
</div>
<div class="paragraph">
<p>Produira le parcours cyclique des cases d’indices <code>0 &gt; 4 &gt; 3 &gt; 2 &gt; 1 &gt; 0 &gt; …​</code>, en effet :</p>
</div>
<div class="literalblock">
<div class="content">
<pre>itération 1 : 40123
              ^
itération 2 : 40123
                  ^
itération 3 : 40123
                 ^
itération 4 : 40123
                ^
itération 5 : 40123
               ^
itération 6 : 40123    &lt;-- retour à la case départ
              ^
itération 7 : 40123
                  ^
etc.</pre>
</div>
</div>
<div class="paragraph">
<p>Là où ça devient intéressant, c’est que certains arrays correspondent à plusieurs cycles indépendants, par exemple, l’array suivant :</p>
</div>
<div class="literalblock">
<div class="content">
<pre>20143</pre>
</div>
</div>
<div class="paragraph">
<p>Produit deux cycles : <code>0 &gt; 2 &gt; 1 &gt; 0 &gt; …​</code> et <code>4 &gt; 3 &gt; 4 &gt; …​</code></p>
</div>
<div class="paragraph">
<p>Bon, ben une permutation cyclique, c’est une permutation d’un <span class="underline">array trié</span> de N entiers tel que l’array permuté <strong>soit constitué d’un seul cycle</strong>, de longueur N.</p>
</div>
<div class="paragraph">
<p>Dans les exemples ci-dessus, si on part de l’array <code>01234</code>, <code>40123</code> en est une permutation cyclique, mais <code>20143</code> en est une permutation non-cyclique.</p>
</div>
<div class="paragraph">
<p> </p></div></details> <p></p>
</div>
</div>
</div>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>

    

  </body>
</html>
